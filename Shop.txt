بله، حتماً! بیایید با این رویکرد شروع کنیم و اول ماژول پایه پروژه رو پیاده‌سازی کنیم.

### 🤔 Think: ماژول اول - ساختار پایه
برای شروع باید به چند نکته فکر کنیم:
1. چرا Flask رو انتخاب می‌کنیم؟
   - سبک و ساده برای شروع
   - انعطاف‌پذیر برای پروژه‌های ماژولار
   - مناسب برای API-first development

2. ساختار پوشه‌ها چطور باشه بهتره؟
   - باید طوری باشه که بعداً به راحتی بتونیم ماژول‌های جدید اضافه کنیم
   - امنیت رو در نظر بگیریم
   - تفکیک واضح بین بخش‌های مختلف

3. چه پیش‌نیازهایی لازم داریم؟
   - پایگاه داده
   - سیستم authentication
   - مدیریت محیط‌های مختلف (development, production)

خب، حالا بیاید شروع کنیم با کدنویسی:

```python name=requirements.txt
# Core Framework
Flask==2.0.1
python-dotenv==0.19.0

# Database
SQLAlchemy==1.4.23
Flask-SQLAlchemy==2.5.1

# Authentication
Flask-Login==0.5.0
Flask-Bcrypt==0.7.1

# Utils
PyJWT==2.1.0
```

```python name=config.py
import os
from datetime import timedelta

class Config:
    """
    تنظیمات پایه برای همه محیط‌ها
    این کلاس شامل تنظیمات مشترک بین همه محیط‌هاست
    """
    SECRET_KEY = os.environ.get('SECRET_KEY', 'your-secret-key-here')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'your-jwt-secret-key')
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)

class DevelopmentConfig(Config):
    """
    تنظیمات محیط توسعه
    دیتابیس SQLite برای راحتی کار در محیط توسعه
    """
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///development.db'

class ProductionConfig(Config):
    """
    تنظیمات محیط تولید
    استفاده از PostgreSQL در محیط تولید
    """
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')

# دیکشنری برای انتخاب کانفیگ مناسب
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
```

```python name=app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from flask_bcrypt import Bcrypt
from config import config

# تعریف متغیرهای گلوبال
db = SQLAlchemy()
login_manager = LoginManager()
bcrypt = Bcrypt()

def create_app(config_name='default'):
    """
    Application Factory برای ساخت اپ فلسک
    این الگو به ما اجازه میده چند نمونه مختلف از اپ با کانفیگ‌های متفاوت بسازیم
    """
    app = Flask(__name__)
    
    # اعمال تنظیمات
    app.config.from_object(config[config_name])
    
    # راه‌اندازی extensions
    db.init_app(app)
    login_manager.init_app(app)
    bcrypt.init_app(app)
    
    # تنظیم login manager
    login_manager.login_view = 'auth.login'
    login_manager.login_message = 'لطفا وارد شوید.'
    login_manager.login_message_category = 'info'
    
    # ثبت blueprints
    from app.auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint)
    
    from app.main import main as main_blueprint
    app.register_blueprint(main_blueprint)
    
    return app
```

### 🤔 Think: مدل‌های پایه
حالا باید به مدل‌های پایه فکر کنیم:
1. کاربر چه فیلدهایی نیاز داره؟
   - اطلاعات اصلی (username, email, password)
   - نقش کاربری (role)
   - فیلدهای زمانی

2. چطور امنیت پسورد رو تأمین کنیم؟
   - استفاده از bcrypt برای هش کردن
   - ذخیره نکردن پسورد خام

```python name=app/models/user.py
from datetime import datetime
from flask_login import UserMixin
from app import db, bcrypt

class User(UserMixin, db.Model):
    """
    مدل کاربر با قابلیت‌های پایه
    UserMixin برای اضافه کردن متدهای مورد نیاز Flask-Login
    """
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    role = db.Column(db.String(20), nullable=False, default='customer')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    @property
    def password(self):
        """
        جلوگیری از دسترسی مستقیم به پسورد
        """
        raise AttributeError('password is not a readable attribute')
    
    @password.setter
    def password(self, password):
        """
        تبدیل پسورد به هش و ذخیره
        """
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')
    
    def verify_password(self, password):
        """
        بررسی صحت پسورد
        """
        return bcrypt.check_password_hash(self.password_hash, password)
    
    def is_admin(self):
        """
        بررسی ادمین بودن کاربر
        """
        return self.role in ['admin', 'owner']
    
    def is_owner(self):
        """
        بررسی صاحب سایت بودن کاربر
        """
        return self.role == 'owner'
```

### 🤔 Think: احراز هویت
برای سیستم احراز هویت باید به این موارد فکر کنیم:
1. چه روش‌هایی برای لاگین نیاز داریم؟
   - لاگین با username/password
   - امکان remember me
   - مدیریت نشست‌ها

2. چطور امنیت رو تأمین کنیم؟
   - استفاده از CSRF token
   - محدودیت تعداد تلاش‌های ناموفق
   - لاگ کردن فعالیت‌های مشکوک

```python name=app/auth/routes.py
from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, login_required
from app.models.user import User
from app import db

auth = Blueprint('auth', __name__)

@auth.route('/login', methods=['GET', 'POST'])
def login():
    """
    مدیریت لاگین کاربران
    شامل نمایش فرم و پردازش اطلاعات ارسالی
    """
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        remember = request.form.get('remember', False)
        
        user = User.query.filter_by(username=username).first()
        
        if user and user.verify_password(password):
            login_user(user, remember=remember)
            next_page = request.args.get('next')
            return redirect(next_page or url_for('main.index'))
        
        flash('نام کاربری یا رمز عبور اشتباه است.', 'error')
    
    return render_template('auth/login.html')
```

```html name=app/templates/auth/login.html
<!DOCTYPE html>
<html>
<head>
    <title>ورود به سیستم</title>
</head>
<body>
    <h1>ورود به سیستم</h1>
    
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            {% for message in messages %}
                <div class="alert">{{ message }}</div>
            {% endfor %}
        {% endif %}
    {% endwith %}
    
    <form method="POST" action="{{ url_for('auth.login') }}">
        <div>
            <label for="username">نام کاربری:</label>
            <input type="text" id="username" name="username" required>
        </div>
        
        <div>
            <label for="password">رمز عبور:</label>
            <input type="password" id="password" name="password" required>
        </div>
        
        <div>
            <label>
                <input type="checkbox" name="remember"> مرا به خاطر بسپار
            </label>
        </div>
        
        <button type="submit">ورود</button>
    </form>
</body>
</html>
```

### 🎯 نکات مهم در این مرحله:
1. ساختار ماژولار با استفاده از Blueprint ها
2. جداسازی تنظیمات محیط‌های مختلف
3. امنیت پایه با استفاده از:
   - هش کردن پسوردها
   - مدیریت نشست‌ها
   - محدودیت دسترسی

آیا مایلید که:
1. به سراغ ماژول بعدی (مدیریت محصولات) بریم؟
2. تست‌های این بخش رو بنویسیم؟
3. یا سوالی در مورد این بخش دارید؟
بله، حالا میریم سراغ ماژول مدیریت محصولات.

### 🤔 Think: ماژول محصولات
قبل از شروع کدنویسی، بیایید به موارد مهم فکر کنیم:

1. مدل محصول چه ویژگی‌هایی نیاز داره؟
   - اطلاعات پایه (نام، توضیحات، قیمت)
   - مدیریت موجودی
   - دسته‌بندی
   - تصاویر محصول
   - تاریخ‌ها برای مدیریت بهتر

2. چه عملیاتی روی محصولات نیاز داریم؟
   - CRUD (Create, Read, Update, Delete)
   - جستجو و فیلتر
   - مرتب‌سازی
   - مدیریت موجودی

3. سطوح دسترسی چطور باشه؟
   - فقط ادمین و صاحب سایت بتونن محصول اضافه/ویرایش کنن
   - همه بتونن محصولات رو ببینن
   - مدیریت موجودی فقط توسط ادمین‌ها

بیاید شروع کنیم به کدنویسی:

```python name=app/models/product.py
from datetime import datetime
from app import db

class Category(db.Model):
    """
    مدل دسته‌بندی محصولات
    این مدل برای سازماندهی بهتر محصولات استفاده میشه
    """
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    description = db.Column(db.String(200))
    products = db.relationship('Product', backref='category', lazy=True)

class Product(db.Model):
    """
    مدل محصول با تمام ویژگی‌های مورد نیاز
    شامل ارتباط با دسته‌بندی و تاریخچه قیمت
    """
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False)
    stock = db.Column(db.Integer, default=0)
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'))
    images = db.relationship('ProductImage', backref='product', lazy=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        """
        تبدیل محصول به دیکشنری برای API
        """
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'price': self.price,
            'stock': self.stock,
            'category': self.category.name if self.category else None,
            'images': [img.url for img in self.images],
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }
    
    def update_stock(self, quantity, operation='add'):
        """
        بروزرسانی موجودی محصول
        operation: 'add' برای اضافه کردن، 'subtract' برای کم کردن
        """
        if operation == 'add':
            self.stock += quantity
        elif operation == 'subtract':
            if self.stock >= quantity:
                self.stock -= quantity
            else:
                raise ValueError('موجودی کافی نیست')
        db.session.commit()

class ProductImage(db.Model):
    """
    مدل تصاویر محصول
    هر محصول می‌تونه چند تا تصویر داشته باشه
    """
    id = db.Column(db.Integer, primary_key=True)
    url = db.Column(db.String(200), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    is_primary = db.Column(db.Boolean, default=False)
```

### 🤔 Think: روت‌ها و کنترلرها
حالا نیاز داریم endpoint های مختلف برای مدیریت محصولات بسازیم:

```python name=app/products/routes.py
from flask import Blueprint, render_template, request, jsonify, abort
from flask_login import login_required, current_user
from app.models.product import Product, Category
from app import db
from app.utils.decorators import admin_required

products = Blueprint('products', __name__)

@products.route('/products')
def list_products():
    """
    نمایش لیست محصولات
    با قابلیت فیلتر و جستجو
    """
    page = request.args.get('page', 1, type=int)
    category = request.args.get('category')
    search = request.args.get('search')
    
    query = Product.query
    
    if category:
        query = query.filter_by(category_id=category)
    if search:
        query = query.filter(Product.name.ilike(f'%{search}%'))
    
    products = query.paginate(page=page, per_page=12)
    categories = Category.query.all()
    
    return render_template('products/list.html', 
                         products=products,
                         categories=categories)

@products.route('/products/<int:id>')
def product_detail(id):
    """
    نمایش جزئیات یک محصول
    """
    product = Product.query.get_or_404(id)
    return render_template('products/detail.html', product=product)

@products.route('/admin/products', methods=['GET', 'POST'])
@login_required
@admin_required
def manage_products():
    """
    مدیریت محصولات - فقط برای ادمین
    """
    if request.method == 'POST':
        # اضافه کردن محصول جدید
        data = request.form
        product = Product(
            name=data['name'],
            description=data['description'],
            price=float(data['price']),
            stock=int(data['stock']),
            category_id=int(data['category'])
        )
        db.session.add(product)
        db.session.commit()
        
        return jsonify(product.to_dict()), 201
    
    # نمایش لیست محصولات برای مدیریت
    products = Product.query.all()
    categories = Category.query.all()
    return render_template('admin/products.html',
                         products=products,
                         categories=categories)
```

```html name=app/templates/products/list.html
<!DOCTYPE html>
<html>
<head>
    <title>محصولات</title>
</head>
<body>
    <h1>لیست محصولات</h1>
    
    <!-- فیلتر و جستجو -->
    <div class="filters">
        <form method="GET">
            <select name="category">
                <option value="">همه دسته‌ها</option>
                {% for category in categories %}
                <option value="{{ category.id }}">{{ category.name }}</option>
                {% endfor %}
            </select>
            
            <input type="text" name="search" placeholder="جستجو...">
            <button type="submit">اعمال فیلتر</button>
        </form>
    </div>

    <!-- لیست محصولات -->
    <div class="products-grid">
        {% for product in products.items %}
        <div class="product-card">
            {% if product.images %}
            <img src="{{ product.images[0].url }}" alt="{{ product.name }}">
            {% endif %}
            
            <h3>{{ product.name }}</h3>
            <p class="price">{{ product.price }} تومان</p>
            
            {% if product.stock > 0 %}
            <p class="stock">موجود در انبار: {{ product.stock }} عدد</p>
            <button onclick="addToCart({{ product.id }})">افزودن به سبد خرید</button>
            {% else %}
            <p class="out-of-stock">ناموجود</p>
            {% endif %}
        </div>
        {% endfor %}
    </div>

    <!-- صفحه‌بندی -->
    <div class="pagination">
        {% if products.has_prev %}
        <a href="{{ url_for('products.list_products', page=products.prev_num) }}">قبلی</a>
        {% endif %}
        
        <span>صفحه {{ products.page }} از {{ products.pages }}</span>
        
        {% if products.has_next %}
        <a href="{{ url_for('products.list_products', page=products.next_num) }}">بعدی</a>
        {% endif %}
    </div>
</body>
</html>
```

```html name=app/templates/admin/products.html
<!DOCTYPE html>
<html>
<head>
    <title>مدیریت محصولات</title>
</head>
<body>
    <h1>مدیریت محصولات</h1>

    <!-- فرم اضافه کردن محصول جدید -->
    <div class="add-product-form">
        <h2>افزودن محصول جدید</h2>
        <form method="POST">
            <div>
                <label for="name">نام محصول:</label>
                <input type="text" id="name" name="name" required>
            </div>
            
            <div>
                <label for="description">توضیحات:</label>
                <textarea id="description" name="description" required></textarea>
            </div>
            
            <div>
                <label for="price">قیمت:</label>
                <input type="number" id="price" name="price" required>
            </div>
            
            <div>
                <label for="stock">موجودی:</label>
                <input type="number" id="stock" name="stock" required>
            </div>
            
            <div>
                <label for="category">دسته‌بندی:</label>
                <select id="category" name="category" required>
                    {% for category in categories %}
                    <option value="{{ category.id }}">{{ category.name }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <button type="submit">افزودن محصول</button>
        </form>
    </div>

    <!-- لیست محصولات -->
    <div class="products-list">
        <h2>لیست محصولات موجود</h2>
        <table>
            <thead>
                <tr>
                    <th>نام</th>
                    <th>قیمت</th>
                    <th>موجودی</th>
                    <th>دسته‌بندی</th>
                    <th>عملیات</th>
                </tr>
            </thead>
            <tbody>
                {% for product in products %}
                <tr>
                    <td>{{ product.name }}</td>
                    <td>{{ product.price }}</td>
                    <td>{{ product.stock }}</td>
                    <td>{{ product.category.name }}</td>
                    <td>
                        <button onclick="editProduct({{ product.id }})">ویرایش</button>
                        <button onclick="deleteProduct({{ product.id }})">حذف</button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</body>
</html>
```

### 🤔 Think: Utilities و Decorators
برای مدیریت بهتر دسترسی‌ها، نیاز به چند decorator داریم:

```python name=app/utils/decorators.py
from functools import wraps
from flask import abort
from flask_login import current_user

def admin_required(f):
    """
    دکوریتور برای محدود کردن دسترسی به ادمین‌ها
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_admin():
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def owner_required(f):
    """
    دکوریتور برای محدود کردن دسترسی به صاحب سایت
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_owner():
            abort(403)
        return f(*args, **kwargs)
    return decorated_function
```

### 🎯 نکات مهم در این مرحله:
1. مدل‌سازی کامل محصولات با در نظر گرفتن:
   - دسته‌بندی
   - تصاویر
   - موجودی
   
2. پیاده‌سازی API‌های مورد نیاز:
   - نمایش محصولات با فیلتر و جستجو
   - مدیریت محصولات برای ادمین
   
3. امنیت و دسترسی:
   - استفاده از decoratorها برای کنترل دسترسی
   - جداسازی بخش‌های عمومی و مدیریتی

4. قابلیت‌های کاربردی:
   - فیلتر و جستجو
   - صفحه‌بندی
   - مدیریت موجودی

آیا مایلید:
1. به سراغ ماژول بعدی (سبد خرید) بریم؟
2. تست‌های این بخش رو بنویسیم؟
3. یا سؤالی در مورد این بخش دارید؟
بسیار خب، بریم سراغ ماژول سبد خرید و سفارشات!

### 🤔 Think: ماژول سبد خرید و سفارشات
باید به چند نکته‌ی مهم فکر کنم:

1. مدیریت سبد خرید:
   - سبد خرید موقت برای کاربران مهمان چطور مدیریت بشه؟
   - چطور اطمینان حاصل کنیم که موجودی در لحظه‌ی خرید کافی هست؟
   - آیا محدودیتی برای تعداد آیتم‌ها در سبد خرید بذاریم؟

2. فرآیند سفارش:
   - وضعیت‌های مختلف سفارش چی‌ها باشن؟
   - چطور از تراکنش‌های همزمان جلوگیری کنیم؟
   - لاگ تغییرات وضعیت سفارش رو کجا نگه داریم؟

3. مسائل امنیتی:
   - چطور از دستکاری قیمت‌ها جلوگیری کنیم؟
   - چطور مطمئن بشیم که کاربر فقط به سفارشات خودش دسترسی داره؟

بیاید شروع کنیم به کدنویسی:

```python name=app/models/cart.py
from datetime import datetime
from app import db
from app.models.product import Product

class Cart(db.Model):
    """
    مدل سبد خرید
    - برای کاربران لاگین شده: user_id پر میشه
    - برای کاربران مهمان: session_id پر میشه
    """
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    session_id = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    items = db.relationship('CartItem', backref='cart', lazy=True, cascade='all, delete-orphan')
    
    @property
    def total_price(self):
        """
        محاسبه قیمت کل سبد خرید
        با در نظر گرفتن تعداد هر محصول
        """
        return sum(item.product.price * item.quantity for item in self.items)
    
    def add_item(self, product_id, quantity=1):
        """
        اضافه کردن محصول به سبد خرید
        اگر محصول قبلاً در سبد باشه، فقط تعدادش اضافه میشه
        """
        existing_item = CartItem.query.filter_by(
            cart_id=self.id, 
            product_id=product_id
        ).first()
        
        if existing_item:
            existing_item.quantity += quantity
        else:
            item = CartItem(product_id=product_id, quantity=quantity)
            self.items.append(item)
        
        db.session.commit()
    
    def update_item(self, product_id, quantity):
        """
        بروزرسانی تعداد یک محصول در سبد خرید
        """
        item = CartItem.query.filter_by(
            cart_id=self.id,
            product_id=product_id
        ).first()
        
        if item:
            if quantity > 0:
                item.quantity = quantity
            else:
                db.session.delete(item)
            
            db.session.commit()

class CartItem(db.Model):
    """
    مدل آیتم‌های داخل سبد خرید
    هر آیتم شامل یک محصول و تعداد آن است
    """
    id = db.Column(db.Integer, primary_key=True)
    cart_id = db.Column(db.Integer, db.ForeignKey('cart.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity = db.Column(db.Integer, default=1)
    product = db.relationship('Product')
```

```python name=app/models/order.py
from datetime import datetime
from app import db

class Order(db.Model):
    """
    مدل سفارش
    شامل اطلاعات کامل سفارش و وضعیت آن
    """
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    status = db.Column(db.String(20), default='pending')  # pending, paid, shipped, delivered, cancelled
    total_price = db.Column(db.Float, nullable=False)
    address = db.Column(db.Text, nullable=False)
    phone = db.Column(db.String(15), nullable=False)
    tracking_code = db.Column(db.String(20), unique=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    items = db.relationship('OrderItem', backref='order', lazy=True)
    status_changes = db.relationship('OrderStatusLog', backref='order', lazy=True)

    def update_status(self, new_status, note=None):
        """
        بروزرسانی وضعیت سفارش
        با ثبت در تاریخچه تغییرات
        """
        if new_status != self.status:
            self.status = new_status
            log = OrderStatusLog(
                order_id=self.id,
                old_status=self.status,
                new_status=new_status,
                note=note
            )
            db.session.add(log)
            db.session.commit()

class OrderItem(db.Model):
    """
    مدل آیتم‌های سفارش
    قیمت هر آیتم در زمان خرید ذخیره میشه
    """
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price = db.Column(db.Float, nullable=False)  # قیمت در زمان خرید
    product = db.relationship('Product')

class OrderStatusLog(db.Model):
    """
    مدل لاگ تغییرات وضعیت سفارش
    برای پیگیری تاریخچه تغییرات
    """
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    old_status = db.Column(db.String(20))
    new_status = db.Column(db.String(20), nullable=False)
    note = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
```

### 🤔 Think: مدیریت سبد خرید
حالا نیاز به API‌ها و روت‌های مدیریت سبد خرید داریم:

```python name=app/cart/routes.py
from flask import Blueprint, jsonify, request, session
from flask_login import current_user, login_required
from app.models.cart import Cart, CartItem
from app.models.product import Product
from app import db

cart = Blueprint('cart', __name__)

def get_or_create_cart():
    """
    گرفتن سبد خرید کاربر یا ساخت سبد جدید
    برای کاربران مهمان از session_id استفاده می‌کنه
    """
    if current_user.is_authenticated:
        cart = Cart.query.filter_by(user_id=current_user.id).first()
    else:
        if 'cart_session_id' not in session:
            session['cart_session_id'] = str(uuid.uuid4())
        cart = Cart.query.filter_by(session_id=session['cart_session_id']).first()
    
    if not cart:
        cart = Cart(
            user_id=current_user.id if current_user.is_authenticated else None,
            session_id=session.get('cart_session_id')
        )
        db.session.add(cart)
        db.session.commit()
    
    return cart

@cart.route('/api/cart/add', methods=['POST'])
def add_to_cart():
    """
    اضافه کردن محصول به سبد خرید
    با بررسی موجودی
    """
    data = request.get_json()
    product_id = data.get('product_id')
    quantity = data.get('quantity', 1)
    
    product = Product.query.get_or_404(product_id)
    
    # بررسی موجودی
    if product.stock < quantity:
        return jsonify({
            'error': 'موجودی کافی نیست',
            'available': product.stock
        }), 400
    
    cart = get_or_create_cart()
    cart.add_item(product_id, quantity)
    
    return jsonify({
        'message': 'محصول به سبد خرید اضافه شد',
        'cart_total': cart.total_price
    })

@cart.route('/api/cart/update', methods=['PUT'])
def update_cart():
    """
    بروزرسانی تعداد محصول در سبد خرید
    """
    data = request.get_json()
    product_id = data.get('product_id')
    quantity = data.get('quantity', 0)
    
    cart = get_or_create_cart()
    cart.update_item(product_id, quantity)
    
    return jsonify({
        'message': 'سبد خرید بروز شد',
        'cart_total': cart.total_price
    })
```

### 🤔 Think: مدیریت سفارش
و در نهایت، API‌های مدیریت سفارش:

```python name=app/orders/routes.py
from flask import Blueprint, jsonify, request
from flask_login import current_user, login_required
from app.models.order import Order, OrderItem
from app.models.cart import Cart
from app import db
import uuid

orders = Blueprint('orders', __name__)

@orders.route('/api/orders/create', methods=['POST'])
@login_required
def create_order():
    """
    ایجاد سفارش از روی سبد خرید
    با بررسی مجدد موجودی و قیمت‌ها
    """
    data = request.get_json()
    cart = Cart.query.filter_by(user_id=current_user.id).first()
    
    if not cart or not cart.items:
        return jsonify({'error': 'سبد خرید خالی است'}), 400
    
    # بررسی موجودی
    for item in cart.items:
        if item.product.stock < item.quantity:
            return jsonify({
                'error': f'موجودی {item.product.name} کافی نیست',
                'available': item.product.stock
            }), 400
    
    try:
        # ایجاد سفارش
        order = Order(
            user_id=current_user.id,
            total_price=cart.total_price,
            address=data['address'],
            phone=data['phone'],
            tracking_code=str(uuid.uuid4())[:8].upper()
        )
        db.session.add(order)
        
        # اضافه کردن آیتم‌ها
        for item in cart.items:
            order_item = OrderItem(
                product_id=item.product_id,
                quantity=item.quantity,
                price=item.product.price
            )
            order.items.append(order_item)
            
            # بروزرسانی موجودی
            item.product.update_stock(item.quantity, 'subtract')
        
        # پاک کردن سبد خرید
        db.session.delete(cart)
        db.session.commit()
        
        return jsonify({
            'message': 'سفارش با موفقیت ثبت شد',
            'order_id': order.id,
            'tracking_code': order.tracking_code
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'خطا در ثبت سفارش'}), 500

@orders.route('/api/orders/<tracking_code>')
@login_required
def get_order(tracking_code):
    """
    دریافت اطلاعات سفارش با کد پیگیری
    فقط برای کاربر صاحب سفارش
    """
    order = Order.query.filter_by(tracking_code=tracking_code).first_or_404()
    
    # بررسی دسترسی
    if order.user_id != current_user.id and not current_user.is_admin():
        return jsonify({'error': 'دسترسی غیرمجاز'}), 403
    
    return jsonify({
        'id': order.id,
        'status': order.status,
        'total_price': order.total_price,
        'tracking_code': order.tracking_code,
        'created_at': order.created_at.isoformat(),
        'items': [{
            'product_name': item.product.name,
            'quantity': item.quantity,
            'price': item.price
        } for item in order.items],
        'status_history': [{
            'status': log.new_status,
            'date': log.created_at.isoformat(),
            'note': log.note
        } for log in order.status_changes]
    })
```

### 🎯 نکات مهم در این مرحله:
1. مدیریت همزمان سبد خرید برای کاربران مهمان و لاگین شده
2. بررسی‌های امنیتی:
   - کنترل موجودی در زمان اضافه کردن به سبد و ثبت سفارش
   - ذخیره قیمت در زمان سفارش برای جلوگیری از مشکلات تغییر قیمت
   - کنترل دسترسی به سفارشات

3. ویژگی‌های پیشرفته:
   - لاگ تغییرات وضعیت سفارش
   - کد پیگیری منحصر به فرد
   - تاریخچه کامل سفارش

4. مدیریت خطاها:
   - استفاده از تراکنش‌ها برای اطمینان از صحت داده‌ها
   - بازگشت خطاهای مناسب به کاربر

آیا مایلید:
1. به سراغ ماژول بعدی (پنل مدیریت) بریم؟
2. نمونه UI برای این بخش ببینید؟
3. یا سؤالی در مورد این بخش دارید؟
خب، بریم سراغ ماژول پنل مدیریت که بخش مهمی از سیستمه!

### 🤔 Think: ماژول پنل مدیریت
قبل از کدنویسی به چند نکته مهم فکر می‌کنم:

1. دسترسی‌های متفاوت:
   - صاحب سایت چه امکاناتی بیشتر از ادمین داشته باشه؟
   - چطور از دسترسی غیرمجاز جلوگیری کنیم؟
   - آیا نیاز به لاگ فعالیت‌های مدیریتی داریم؟

2. داشبورد و گزارشات:
   - چه آماری برای صاحب سایت مهمه؟
   - گزارشات مالی چطور محاسبه و نمایش داده بشن؟
   - نمودارها و گراف‌ها چطور آپدیت بشن؟

3. عملکرد و کارایی:
   - چطور از کش استفاده کنیم برای گزارشات سنگین؟
   - محاسبات رو کجا انجام بدیم که سرور رو درگیر نکنه؟

بیاید شروع کنیم به کدنویسی:

```python name=app/admin/models.py
from datetime import datetime
from app import db

class AdminLog(db.Model):
    """
    مدل لاگ فعالیت‌های مدیریتی
    برای ثبت و پیگیری تغییرات مهم
    """
    id = db.Column(db.Integer, primary_key=True)
    admin_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    action = db.Column(db.String(50), nullable=False)  # نوع عملیات
    entity_type = db.Column(db.String(50))  # نوع موجودیت (محصول، سفارش و...)
    entity_id = db.Column(db.Integer)  # شناسه موجودیت
    details = db.Column(db.JSON)  # جزئیات تغییرات
    ip_address = db.Column(db.String(45))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class DashboardCache(db.Model):
    """
    مدل کش داشبورد
    برای ذخیره موقت گزارشات سنگین
    """
    id = db.Column(db.Integer, primary_key=True)
    cache_key = db.Column(db.String(100), unique=True, nullable=False)
    data = db.Column(db.JSON)
    expires_at = db.Column(db.DateTime, nullable=False)
```

```python name=app/admin/utils.py
from datetime import datetime, timedelta
from app.models.order import Order
from app.models.product import Product
from app.admin.models import DashboardCache
from app import db
import json

def get_sales_stats(period='daily'):
    """
    محاسبه آمار فروش
    با قابلیت کش کردن نتایج
    """
    cache_key = f'sales_stats_{period}_{datetime.now().strftime("%Y%m%d")}'
    cached = DashboardCache.query.filter_by(cache_key=cache_key).first()
    
    if cached and cached.expires_at > datetime.now():
        return json.loads(cached.data)
    
    # محاسبه آمار جدید
    if period == 'daily':
        start_date = datetime.now() - timedelta(days=30)
        group_format = '%Y-%m-%d'
    elif period == 'monthly':
        start_date = datetime.now() - timedelta(days=365)
        group_format = '%Y-%m'
    
    sales_data = db.session.query(
        db.func.strftime(group_format, Order.created_at).label('date'),
        db.func.sum(Order.total_price).label('total'),
        db.func.count(Order.id).label('count')
    ).filter(
        Order.status == 'delivered',
        Order.created_at >= start_date
    ).group_by('date').all()
    
    result = {
        'labels': [row.date for row in sales_data],
        'totals': [float(row.total) for row in sales_data],
        'counts': [row.count for row in sales_data]
    }
    
    # ذخیره در کش
    cache = DashboardCache(
        cache_key=cache_key,
        data=json.dumps(result),
        expires_at=datetime.now() + timedelta(hours=1)
    )
    db.session.add(cache)
    db.session.commit()
    
    return result

def log_admin_action(admin_user, action, entity_type=None, entity_id=None, details=None, request=None):
    """
    ثبت فعالیت‌های مدیریتی
    """
    log = AdminLog(
        admin_id=admin_user.id,
        action=action,
        entity_type=entity_type,
        entity_id=entity_id,
        details=details,
        ip_address=request.remote_addr if request else None
    )
    db.session.add(log)
    db.session.commit()
```

```python name=app/admin/routes.py
from flask import Blueprint, render_template, jsonify, request
from flask_login import login_required, current_user
from app.utils.decorators import admin_required, owner_required
from app.admin.utils import get_sales_stats, log_admin_action
from app.models.order import Order
from app.models.product import Product
from app.models.user import User
from app import db

admin = Blueprint('admin', __name__)

@admin.route('/admin/dashboard')
@login_required
@admin_required
def dashboard():
    """
    داشبورد اصلی مدیریت
    نمایش آمار کلی و نمودارها
    """
    # آمار کلی
    stats = {
        'total_orders': Order.query.count(),
        'pending_orders': Order.query.filter_by(status='pending').count(),
        'total_products': Product.query.count(),
        'low_stock_products': Product.query.filter(Product.stock < 10).count(),
        'total_users': User.query.filter_by(role='customer').count()
    }
    
    # آمار فروش
    sales_data = get_sales_stats('daily')
    
    return render_template('admin/dashboard.html',
                         stats=stats,
                         sales_data=sales_data)

@admin.route('/admin/orders')
@login_required
@admin_required
def manage_orders():
    """
    مدیریت سفارشات
    با قابلیت فیلتر و جستجو
    """
    page = request.args.get('page', 1, type=int)
    status = request.args.get('status')
    search = request.args.get('search')
    
    query = Order.query
    
    if status:
        query = query.filter_by(status=status)
    if search:
        query = query.join(User).filter(
            (User.username.ilike(f'%{search}%')) |
            (Order.tracking_code.ilike(f'%{search}%'))
        )
    
    orders = query.order_by(Order.created_at.desc()).paginate(
        page=page, per_page=20
    )
    
    return render_template('admin/orders.html', orders=orders)

@admin.route('/admin/users')
@login_required
@owner_required
def manage_users():
    """
    مدیریت کاربران - فقط برای صاحب سایت
    """
    users = User.query.order_by(User.created_at.desc()).all()
    return render_template('admin/users.html', users=users)

@admin.route('/admin/reports/sales', methods=['GET'])
@login_required
@owner_required
def sales_report():
    """
    گزارش فروش - فقط برای صاحب سایت
    با فیلترهای مختلف و امکان دانلود
    """
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    query = db.session.query(
        Order.id,
        User.username,
        Order.total_price,
        Order.status,
        Order.created_at
    ).join(User)
    
    if start_date:
        query = query.filter(Order.created_at >= start_date)
    if end_date:
        query = query.filter(Order.created_at <= end_date)
    
    results = query.all()
    
    if request.args.get('download'):
        # ایجاد فایل CSV برای دانلود
        return create_csv_response(results)
    
    return jsonify([{
        'order_id': r.id,
        'username': r.username,
        'total': r.total_price,
        'status': r.status,
        'date': r.created_at.isoformat()
    } for r in results])
```

```html name=app/templates/admin/dashboard.html
<!DOCTYPE html>
<html>
<head>
    <title>پنل مدیریت - داشبورد</title>
</head>
<body>
    <h1>داشبورد مدیریت</h1>

    <!-- آمار کلی -->
    <div class="stats-grid">
        <div class="stat-card">
            <h3>سفارشات</h3>
            <p class="number">{{ stats.total_orders }}</p>
            <p class="subtitle">سفارشات در انتظار: {{ stats.pending_orders }}</p>
        </div>
        
        <div class="stat-card">
            <h3>محصولات</h3>
            <p class="number">{{ stats.total_products }}</p>
            <p class="subtitle">موجودی کم: {{ stats.low_stock_products }}</p>
        </div>
        
        <div class="stat-card">
            <h3>کاربران</h3>
            <p class="number">{{ stats.total_users }}</p>
        </div>
    </div>

    <!-- نمودار فروش -->
    <div class="sales-chart">
        <h3>نمودار فروش</h3>
        <div class="chart-controls">
            <button onclick="updateChart('daily')">روزانه</button>
            <button onclick="updateChart('monthly')">ماهانه</button>
        </div>
        <canvas id="salesChart"></canvas>
    </div>

    <!-- آخرین فعالیت‌ها -->
    <div class="recent-activity">
        <h3>آخرین فعالیت‌ها</h3>
        <table>
            <thead>
                <tr>
                    <th>تاریخ</th>
                    <th>ادمین</th>
                    <th>عملیات</th>
                    <th>جزئیات</th>
                </tr>
            </thead>
            <tbody id="activityLog">
                <!-- با JavaScript پر میشه -->
            </tbody>
        </table>
    </div>
</body>
</html>
```

### 🎯 نکات مهم در این ماژول:
1. مدیریت دسترسی‌ها:
   - تفکیک عملیات‌های مخصوص صاحب سایت
   - لاگ کردن همه فعالیت‌های مدیریتی
   - کنترل دسترسی در سطح API

2. بهینه‌سازی عملکرد:
   - کش کردن گزارشات سنگین
   - صفحه‌بندی برای لیست‌های طولانی
   - کوئری‌های بهینه‌شده

3. ویژگی‌های پیشرفته:
   - گزارشات آماری متنوع
   - نمودارهای تعاملی
   - امکان دانلود گزارشات

4. امنیت:
   - ثبت IP برای فعالیت‌های مدیریتی
   - محدودیت دسترسی براساس نقش
   - لاگ تمام تغییرات حساس

آیا مایلید:
1. به سراغ ماژول آخر (سیستم نظرات و امتیازدهی) بریم؟
2. تست‌های این بخش رو بنویسیم؟
3. یا سؤالی در مورد این بخش دارید؟
بله، بیایید به سراغ ماژول نظرات و امتیازدهی بریم که آخرین بخش پروژه‌مونه!

### 🤔 Think: ماژول نظرات و امتیازدهی
قبل از شروع کدنویسی به نکات مهم فکر می‌کنم:

1. مدیریت نظرات:
   - چطور از نظرات اسپم جلوگیری کنیم؟
   - آیا کاربر باید محصول رو خریده باشه تا بتونه نظر بده؟
   - چطور میانگین امتیازات رو بروز نگه داریم؟

2. سیستم امتیازدهی:
   - مقیاس امتیازدهی چند ستاره باشه؟ (5 ستاره معمول‌تره)
   - آیا امکان ویرایش امتیاز وجود داشته باشه؟
   - چطور امتیازات رو تحلیل کنیم؟

3. مدیریت محتوا:
   - فیلتر کردن محتوای نامناسب؟
   - امکان گزارش نظرات نامناسب؟
   - سیستم تأیید نظرات چطور باشه؟

بیاید شروع کنیم به کدنویسی:

```python name=app/models/review.py
from datetime import datetime
from app import db
from sqlalchemy.event import listens_for
from sqlalchemy import func

class Review(db.Model):
    """
    مدل نظرات و امتیازات محصولات
    با قابلیت تأیید و گزارش
    """
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'))  # برای تأیید خرید
    rating = db.Column(db.Integer, nullable=False)  # 1 تا 5
    comment = db.Column(db.Text)
    pros = db.Column(db.Text)  # نقاط قوت
    cons = db.Column(db.Text)  # نقاط ضعف
    is_verified = db.Column(db.Boolean, default=False)  # تأیید شده توسط ادمین
    is_purchased = db.Column(db.Boolean, default=False)  # آیا محصول خریداری شده
    reports_count = db.Column(db.Integer, default=0)  # تعداد گزارش‌های نامناسب بودن
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relations
    user = db.relationship('User', backref='reviews')
    product = db.relationship('Product', backref='reviews')
    replies = db.relationship('ReviewReply', backref='review', lazy=True)
    
    def to_dict(self):
        """
        تبدیل نظر به دیکشنری برای API
        """
        return {
            'id': self.id,
            'user': self.user.username,
            'rating': self.rating,
            'comment': self.comment,
            'pros': self.pros.split('\n') if self.pros else [],
            'cons': self.cons.split('\n') if self.cons else [],
            'is_verified': self.is_verified,
            'is_purchased': self.is_purchased,
            'created_at': self.created_at.isoformat(),
            'replies': [reply.to_dict() for reply in self.replies]
        }

class ReviewReply(db.Model):
    """
    مدل پاسخ به نظرات
    برای پاسخ‌های ادمین یا فروشنده
    """
    id = db.Column(db.Integer, primary_key=True)
    review_id = db.Column(db.Integer, db.ForeignKey('review.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    user = db.relationship('User')
    
    def to_dict(self):
        return {
            'user': self.user.username,
            'content': self.content,
            'created_at': self.created_at.isoformat()
        }

class ReportedReview(db.Model):
    """
    مدل گزارش نظرات نامناسب
    """
    id = db.Column(db.Integer, primary_key=True)
    review_id = db.Column(db.Integer, db.ForeignKey('review.id'), nullable=False)
    reporter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    reason = db.Column(db.String(100), nullable=False)
    details = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

# Event listeners for updating product rating
@listens_for(Review, 'after_insert')
@listens_for(Review, 'after_update')
@listens_for(Review, 'after_delete')
def update_product_rating(mapper, connection, target):
    """
    بروزرسانی خودکار میانگین امتیاز محصول
    هر بار که نظری اضافه، ویرایش یا حذف می‌شود
    """
    avg_rating = db.session.query(func.avg(Review.rating))\
        .filter(Review.product_id == target.product_id,
                Review.is_verified == True)\
        .scalar()
    
    if avg_rating:
        connection.execute(
            Product.__table__.update()
            .where(Product.id == target.product_id)
            .values(average_rating=float(avg_rating))
        )
```

```python name=app/reviews/routes.py
from flask import Blueprint, jsonify, request
from flask_login import current_user, login_required
from app.models.review import Review, ReviewReply, ReportedReview
from app.models.order import Order
from app.utils.decorators import admin_required
from app import db
import bleach  # برای پاکسازی HTML از نظرات

reviews = Blueprint('reviews', __name__)

@reviews.route('/api/products/<int:product_id>/reviews', methods=['POST'])
@login_required
def add_review(product_id):
    """
    افزودن نظر جدید
    با بررسی خرید محصول و پاکسازی محتوا
    """
    # بررسی خرید محصول
    has_purchased = Order.query.join(OrderItem)\
        .filter(Order.user_id == current_user.id,
                OrderItem.product_id == product_id,
                Order.status == 'delivered')\
        .first() is not None
    
    data = request.get_json()
    
    # پاکسازی محتوا
    clean_comment = bleach.clean(data.get('comment', ''), tags=[])
    clean_pros = bleach.clean(data.get('pros', ''), tags=[])
    clean_cons = bleach.clean(data.get('cons', ''), tags=[])
    
    review = Review(
        user_id=current_user.id,
        product_id=product_id,
        rating=data['rating'],
        comment=clean_comment,
        pros=clean_pros,
        cons=clean_cons,
        is_purchased=has_purchased
    )
    
    db.session.add(review)
    db.session.commit()
    
    return jsonify(review.to_dict()), 201

@reviews.route('/api/reviews/<int:review_id>/reply', methods=['POST'])
@login_required
@admin_required
def reply_to_review(review_id):
    """
    پاسخ به نظر توسط ادمین
    """
    review = Review.query.get_or_404(review_id)
    data = request.get_json()
    
    reply = ReviewReply(
        review_id=review_id,
        user_id=current_user.id,
        content=bleach.clean(data['content'], tags=[])
    )
    
    db.session.add(reply)
    db.session.commit()
    
    return jsonify(reply.to_dict()), 201

@reviews.route('/api/reviews/<int:review_id>/report', methods=['POST'])
@login_required
def report_review(review_id):
    """
    گزارش نظر نامناسب
    """
    review = Review.query.get_or_404(review_id)
    data = request.get_json()
    
    # بررسی گزارش تکراری
    existing_report = ReportedReview.query.filter_by(
        review_id=review_id,
        reporter_id=current_user.id
    ).first()
    
    if existing_report:
        return jsonify({'error': 'شما قبلاً این نظر را گزارش کرده‌اید'}), 400
    
    report = ReportedReview(
        review_id=review_id,
        reporter_id=current_user.id,
        reason=data['reason'],
        details=data.get('details')
    )
    
    review.reports_count += 1
    db.session.add(report)
    db.session.commit()
    
    # اگر تعداد گزارش‌ها از حد مجاز بیشتر شد
    if review.reports_count >= 5:
        review.is_verified = False
        db.session.commit()
    
    return jsonify({'message': 'گزارش شما ثبت شد'}), 201

@reviews.route('/api/admin/reviews/pending')
@login_required
@admin_required
def get_pending_reviews():
    """
    دریافت نظرات در انتظار تأیید
    """
    reviews = Review.query.filter_by(is_verified=False)\
        .order_by(Review.reports_count.desc(),
                 Review.created_at.desc())\
        .all()
    
    return jsonify([review.to_dict() for review in reviews])

@reviews.route('/api/admin/reviews/<int:review_id>/verify', methods=['POST'])
@login_required
@admin_required
def verify_review(review_id):
    """
    تأیید نظر توسط ادمین
    """
    review = Review.query.get_or_404(review_id)
    review.is_verified = True
    review.reports_count = 0  # ریست کردن گزارش‌ها
    db.session.commit()
    
    return jsonify({'message': 'نظر تأیید شد'})
```

```html name=app/templates/products/reviews.html
<!DOCTYPE html>
<html>
<head>
    <title>نظرات محصول</title>
</head>
<body>
    <div class="reviews-section">
        <!-- خلاصه امتیازات -->
        <div class="ratings-summary">
            <div class="average-rating">
                <h3>میانگین امتیاز</h3>
                <div class="stars">
                    {% for i in range(5) %}
                        {% if i < product.average_rating|round|int %}
                            ★
                        {% else %}
                            ☆
                        {% endif %}
                    {% endfor %}
                </div>
                <p>{{ "%.1f"|format(product.average_rating) }} از 5</p>
            </div>
            
            <div class="rating-bars">
                {% for i in range(5, 0, -1) %}
                <div class="rating-bar">
                    <span>{{ i }} ستاره</span>
                    <div class="bar">
                        <div class="fill" style="width: {{ (rating_counts[i] / total_reviews * 100)|round }}%"></div>
                    </div>
                    <span>{{ rating_counts[i] }}</span>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- فرم ثبت نظر -->
        {% if current_user.is_authenticated %}
        <div class="review-form">
            <h3>نظر خود را ثبت کنید</h3>
            <form id="reviewForm" onsubmit="submitReview(event)">
                <div class="rating-input">
                    {% for i in range(5, 0, -1) %}
                    <input type="radio" name="rating" value="{{ i }}" id="star{{ i }}">
                    <label for="star{{ i }}">★</label>
                    {% endfor %}
                </div>
                
                <div>
                    <label>نقاط قوت:</label>
                    <textarea name="pros" placeholder="نقاط مثبت محصول را بنویسید..."></textarea>
                </div>
                
                <div>
                    <label>نقاط ضعف:</label>
                    <textarea name="cons" placeholder="نقاط منفی محصول را بنویسید..."></textarea>
                </div>
                
                <div>
                    <label>نظر کلی:</label>
                    <textarea name="comment" required placeholder="نظر خود را بنویسید..."></textarea>
                </div>
                
                <button type="submit">ثبت نظر</button>
            </form>
        </div>
        {% endif %}

        <!-- لیست نظرات -->
        <div class="reviews-list">
            <h3>نظرات کاربران</h3>
            {% for review in reviews %}
            <div class="review-card">
                <div class="review-header">
                    <span class="user">{{ review.user.username }}</span>
                    {% if review.is_purchased %}
                    <span class="verified-purchase">خریدار محصول</span>
                    {% endif %}
                    <div class="stars">
                        {% for i in range(5) %}
                            {% if i < review.rating %}
                                ★
                            {% else %}
                                ☆
                            {% endif %}
                        {% endfor %}
                    </div>
                </div>
                
                {% if review.pros %}
                <div class="pros">
                    <h4>نقاط قوت:</h4>
                    <ul>
                        {% for pro in review.pros.split('\n') %}
                        <li>{{ pro }}</li>
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
                
                {% if review.cons %}
                <div class="cons">
                    <h4>نقاط ضعف:</h4>
                    <ul>
                        {% for con in review.cons.split('\n') %}
                        <li>{{ con }}</li>
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
                
                <p class="comment">{{ review.comment }}</p>
                
                <div class="review-footer">
                    <span class="date">{{ review.created_at|date }}</span>
                    {% if current_user.is_authenticated %}
                    <button onclick="reportReview({{ review.id }})">گزارش</button>
                    {% endif %}
                </div>

                <!-- پاسخ‌های ادمین -->
                {% for reply in review.replies %}
                <div class="admin-reply">
                    <strong>پاسخ مدیر:</strong>
                    <p>{{ reply.content }}</p>
                    <span class="date">{{ reply.created_at|date }}</span>
                </div>
                {% endfor %}
            </div>
            {% endfor %}
        </div>
    </div>
</body>
</html>
```

### 🎯 نکات مهم در این ماژول:
1. امنیت و کیفیت محتوا:
   - پاکسازی HTML از نظرات با bleach
   - سیستم گزارش نظرات نامناسب
   - تأیید نظرات توسط ادمین

2. قابلیت‌های پیشرفته:
   - جداسازی نقاط قوت و ضعف
   - نمایش برچسب "خریدار محصول"
   - امکان پاسخ ادمین به نظرات

3. تحلیل و آمار:
   - محاسبه خودکار میانگین امتیازات
   - نمایش نمودار توزیع امتیازات
   - تفکیک نظرات تأیید شده و نشده

4. بهینه‌سازی:
   - استفاده از Event Listeners برای بروزرسانی امتیازات
   - کش کردن آمارهای پرکاربرد
   - صفحه‌بندی نظرات

این آخرین ماژول از پروژه فروشگاهی ما بود. آیا مایلید:
1. یک مرور کلی روی کل پروژه داشته باشیم؟
2. تست‌های یکپارچه‌سازی بنویسیم؟
3. یا سؤال خاصی در مورد هر بخش دارید؟
بله، بیایید یک مرور کلی روی کل پروژه فروشگاهی داشته باشیم!

### 🤔 Think: بررسی کلی پروژه
قبل از مرور، به نکات مهم فکر می‌کنم:
1. آیا همه ماژول‌ها به خوبی با هم در ارتباطند؟
2. امنیت در همه بخش‌ها رعایت شده؟
3. مقیاس‌پذیری پروژه چطوره؟

### 📚 مرور کلی ماژول‌ها:

#### 1️⃣ ساختار پایه و احراز هویت
```python
# ساختار اصلی پروژه
ecommerce/
├── backend/
│   ├── __init__.py
│   ├── config.py
│   ├── models/
│   ├── routes/
│   └── utils/
```
- سیستم احراز هویت با Flask-Login
- سه سطح دسترسی: صاحب سایت، ادمین، کاربر عادی
- مدیریت نشست‌ها و امنیت پایه

#### 2️⃣ مدیریت محصولات
```python
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    price = db.Column(db.Float)
    stock = db.Column(db.Integer)
    # ...
```
- CRUD کامل محصولات
- مدیریت موجودی
- دسته‌بندی و تصاویر محصولات

#### 3️⃣ سبد خرید و سفارشات
```python
class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    status = db.Column(db.String(20))
    total_price = db.Column(db.Float)
    tracking_code = db.Column(db.String(20))
    # ...
```
- سبد خرید موقت برای کاربران مهمان
- پیگیری سفارشات با کد رهگیری
- تاریخچه وضعیت سفارشات

#### 4️⃣ پنل مدیریت
```python
class AdminLog(db.Model):
    admin_id = db.Column(db.Integer)
    action = db.Column(db.String(50))
    details = db.Column(db.JSON)
    # ...
```
- داشبورد با آمار و نمودارها
- گزارشات فروش
- لاگ فعالیت‌های مدیریتی

#### 5️⃣ نظرات و امتیازدهی
```python
class Review(db.Model):
    rating = db.Column(db.Integer)
    comment = db.Column(db.Text)
    is_verified = db.Column(db.Boolean)
    # ...
```
- سیستم امتیازدهی 5 ستاره
- مدیریت نظرات نامناسب
- پاسخ به نظرات توسط ادمین

### 🔒 امنیت در کل پروژه:
1. احراز هویت و مجوزها:
```python
@admin_required
def admin_only_function():
    # ...

@login_required
def user_function():
    # ...
```

2. محافظت از داده‌ها:
```python
# پاکسازی ورودی‌ها
clean_data = bleach.clean(user_input)

# هش کردن پسورد
password_hash = bcrypt.generate_password_hash(password)
```

3. لاگ و مانیتورینگ:
```python
def log_admin_action(admin, action, details):
    log = AdminLog(admin_id=admin.id, action=action)
    db.session.add(log)
```

### 📈 مقیاس‌پذیری:
1. کش‌گذاری:
```python
class DashboardCache(db.Model):
    cache_key = db.Column(db.String(100))
    data = db.Column(db.JSON)
    expires_at = db.Column(db.DateTime)
```

2. صفحه‌بندی:
```python
@app.route('/products')
def list_products():
    page = request.args.get('page', 1, type=int)
    products = Product.query.paginate(page=page, per_page=20)
```

### 🌟 ویژگی‌های برجسته:
1. طراحی ماژولار و قابل توسعه
2. سیستم جامع مدیریت محصولات و سفارشات
3. داشبورد مدیریتی پیشرفته
4. سیستم نظرات و امتیازدهی کامل

### 📝 پیشنهادات برای توسعه آینده:
1. اضافه کردن سیستم تخفیف و کوپن
2. پیاده‌سازی API برای اپلیکیشن موبایل
3. اضافه کردن سیستم اطلاع‌رسانی (ایمیل/پیامک)
4. بهینه‌سازی بیشتر برای مقیاس‌پذیری

### 🔍 نکات فنی مهم:
1. استفاده از SQLAlchemy برای ORM
2. Flask Blueprint برای ساختار ماژولار
3. سیستم تمپلیت Jinja2 برای رندر HTML
4. مدیریت خطا و لاگینگ مناسب

آیا مایلید:
1. روی بخش خاصی از پروژه تمرکز کنیم؟
2. تست‌نویسی را شروع کنیم؟
3. یا به سراغ توسعه یکی از قابلیت‌های پیشنهادی برویم؟
